View(df)
nrow(questionnaire_df)
questionnaire_df <- df[df$trialType == "Questionnaire", , drop = FALSE]
if (nrow(questionnaire_df) != 1) {
warning("Empty 'questionnaire_df' where data expected. In future steps, 'score_questionnaire' will not run correctly.")
}
behavior <- summarize_behavior(task_df)
length(test_data$rt)
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
if (!is.numeric(data$rt)) data$rt <- as.numeric(data$rt)
summarize_behavior <- function(data, rt_min = 300, rt_max = 900) {
## Check if rt column is numeric
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
# if (!is.numeric(data$rt)) data$rt <- as.numeric(data$rt)
#
## Change correct column to logical
## Create robust version of as.logical()
normalize_logical <- function(x) {
if (is.logical(x)) return(x)
if (is.numeric(x)) return(x == 1)
if (is.character(x)) return(toupper(x) == "TRUE")
as.logical(x)
}
if (!is.logical(data$correct)) {
data$correct <- normalize_logical(data$correct)
}
## Filter out trials where RT was outside of the threshold range
valid_data_rt <- data[data[ , 3] >= 300 & data[ , 3] <= 900 & data[ , 12] == TRUE, ]
valid_data_acc <- data[data[ , 3] >= 300 & data[ , 3] <= 900, ]
## Center each participant’s reaction times:
## subtract the participant’s mean RT so centered RTs average to zero
valid_data_rt$rt_centered <- NA_real_
for (i in 1:nrow(valid_data_rt)) {
valid_data_rt$rt_centered[i] <- valid_data_rt$rt[i] - mean(valid_data_rt$rt, na.rm = TRUE)
}
## Prepare test trials by excluding practice trials
## Keep only trials where expectedCategory is:
## "school or anxiety" OR "nature or serenity" (congruent)
## "school or serenity" OR "nature or anxiety" (incongruent)
test_data_rt <- valid_data_rt[grepl(" or ", valid_data_rt$expectedCategory), , drop = FALSE]
test_data_acc <- valid_data_acc[grepl(" or ", valid_data_acc$expectedCategory), , drop = FALSE]
## Group trials by the category displayed
desired_order <- c(
"nature or serenity or school or anxiety",
"nature or anxiety or school or serenity"
)
grp_rt <- factor(
test_data_rt$expectedCategoryDisplayed,
levels = desired_order
)
grp_acc <- factor(
test_data_acc$expectedCategoryAsDisplayed,
levels = desired_order
)
## Calculate mean rt
means <- tapply(test_data_rt$rt, grp_rt, FUN = mean)
## If you see “arguments must have same length” from tapply(), check whether the grouping variable (grp) has the same number of rows as test_data$rt. Inspect grp and test_data side by side:
##   length(test_data$rt)
##   length(grp)
## A mismatched or misspelled column name in the factor() call will usually cause this.
## Calculate mean accuracy
accuracy <- tapply(test_data_acc$correct, grp_acc, FUN = mean)
## Calculate D Score
d_score  <- calculate_iat_dscore(test_data_rt)
## Create one-row summary data frame
participant_summary <- data.frame(
congruent_mean       = means[1],
incongruent_mean     = means[2],
congruent_accuracy   = accuracy[1],
incongruent_accuracy = accuracy[2],
d_score              = d_score,
stringsAsFactors     = FALSE,
row.names            = NULL
)
## Ensure Accuracy Values are between 0 and 1
acc_cols <- c("congruent_accuracy", "incongruent_accuracy")
for (col in acc_cols) {
val <- participant_summary[[col]]
if (!is.na(val) && (val < 0 || val > 1)) {
warning(paste(col, "is outside [0, 1]. Check 'correct' coding."))
}
}
## Ensure Mean RTs within [rt_min, rt_max]
rt_cols <- c("congruent_mean", "incongruent_mean")
for (col in rt_cols) {
val <- participant_summary[[col]]
if (!is.na(val) && (val < rt_min || val > rt_max)) {
warning(paste(col, "is outside range [", rt_min, ", ", rt_max, "]."))
}
}
return(participant_summary)
}
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
summarize_behavior <- function(data, rt_min = 300, rt_max = 900) {
## Check if rt column is numeric
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
normalize_logical <- function(x) {
if (is.logical(x)) return(x)
if (is.numeric(x)) return(x == 1)
if (is.character(x)) return(toupper(x) == "TRUE")
as.logical(x)
}
if (!is.logical(data$correct)) {
data$correct <- normalize_logical(data$correct)
}
valid_data_rt <- data[data[ , 3] >= 300 & data[ , 3] <= 900 & data[ , 12] == TRUE, ]
valid_data_acc <- data[data[ , 3] >= 300 & data[ , 3] <= 900, ]
valid_data_rt$rt_centered <- NA_real_
for (i in 1:nrow(valid_data_rt)) {
valid_data_rt$rt_centered[i] <- valid_data_rt$rt[i] - mean(valid_data_rt$rt, na.rm = TRUE)
}
test_data_rt <- valid_data_rt[grepl(" or ", valid_data_rt$expectedCategory), , drop = FALSE]
test_data_acc <- valid_data_acc[grepl(" or ", valid_data_acc$expectedCategory), , drop = FALSE]
test_data_rt <- valid_data_rt[grepl(" or ", valid_data_rt$expectedCategory), , drop = FALSE]
desired_order <- c(
"nature or serenity or school or anxiety",
"nature or anxiety or school or serenity"
)
grp_rt <- factor(
test_data_rt$expectedCategoryDisplayed,
levels = desired_order
)
grp_acc <- factor(
test_data_acc$expectedCategoryAsDisplayed,
levels = desired_order
)
means <- tapply(test_data_rt$rt, grp_rt, FUN = mean)
length(test_data$rt)
length(test_data$rt)
behavior <- summarize_behavior(task_df)
anxiety_score <- score_questionnaire(questionnaire_df$response)
dir.create(
here::here("data", "cleaned", "participants"),
recursive = TRUE,
showWarnings = FALSE
)
df_clean <- data.frame(
subject_id = subject_id,
anxiety_score = anxiety_score,
congruent_mean = behavior["congruent_mean"],
incongruent_mean = behavior["incongruent_mean"],
congruent_accuracy = behavior["congruent_accuracy"],
incongruent_accuracy = behavior["incongruent_accuracy"],
d_score = behavior["d_score"],
row.names = NULL
)
write.csv(
df_clean,
here::here("data", "cleaned", "participants", paste0(subject_id, "_cleaned.csv")),
row.names = FALSE
)
stopifnot(nrow(df_clean) == 1)  # one row per participant
return(df_clean)
}
participant_wide <- build_participant_wide()
df <- read.csv(
here::here(file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
df <- read.csv(
here::here(file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
subject_id <- sub("\\.csv$", "", basename(file_name))
df <- read.csv(
here::here(file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
participant_wide <- build_participant_wide()
files <- list.files(
here::here("data", "raw"),
pattern = "sub-.*\\.csv$",
full.names = TRUE
)
here::here("data", "raw")
here::here(file_name)
here::here("data", "raw", file_name)
here::here(file_name)
files <- list.files(
here::here(file_name),
pattern = "sub-.*\\.csv$",
full.names = TRUE
)
if (length(files) == 0L) stop("No CSV files found in data/raw")
files <- list.files(
here::here("data", "raw"),
pattern = "sub-.*\\.csv$",
full.names = TRUE
)
if (length(files) == 0L) stop("No CSV files found in data/raw")
rows <- list()
for (i in seq_along(files)) {
file_name <- files[i]
rows[[i]] <- import_and_process(file_name)
}
df <- read.csv(
here::here("data", "raw"),
check.names = FALSE,
stringsAsFactors = FALSE
)
df <- read.csv(
here::here("data", "raw"),
check.names = FALSE,
stringsAsFactors = FALSE
)
df <- read.csv(
here::here(file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
for (i in seq_along(files)) {
file_name <- files[i]
rows[[i]] <- import_and_process(file_name)
}
here::here(file_name)
for (i in seq_along(files)) {
file_name <- files[i]
rows[[i]] <- import_and_process(file_name)
}
df <- read.csv(
file_name,
check.names = FALSE,
stringsAsFactors = FALSE
)
for (i in seq_along(files)) {
file_name <- files[i]
rows[[i]] <- import_and_process(file_name)
}
import_and_process <- function(file_name) {
#### Read participant CSV ----------------------------------------------------
# subject_id <- sub("\\.csv$", "", basename(file_name))
#
df <- read.csv(
file_name,
check.names = FALSE,
stringsAsFactors = FALSE
)
# df <- read.csv(
#   here::here(file_name),
#   check.names = FALSE,
#   stringsAsFactors = FALSE
# )
## If you see an error "cannot open the connection", it usually means that R cannot find something where it's looking. Check your paths, files, and file_name. Remember where file_name comes from.
#### Check expected columns ----------------------------
## If this fails, write code using if(), %in%, and names() to rename any
## mismatched column names reproducibly every time you render from the raw data
required_cols <- c("trialType", "block", "rt", "response", "trial_index",
"time_elapsed", "word", "expectedCategory",
"expectedCategoryAsDisplayed", "leftCategory", "rightCategory",
"correct", "question_order")
# Don't refactor to ifelse() - later when doing the AI comparison, you can ask why
if (!all(required_cols %in% names(df))) {
stop(
paste(
"Input data frame missing required columns in",
sub("\\.csv$", "", basename(file_name)),
"\nExpected:",
paste(required_cols, collapse = ", "),
"\nFound:",
paste(names(df), collapse = ", ")
)
)
}
#### Extract subject_id from file name ---------------------------------------
id <- regmatches(file_name, regexpr("sub-[0-9]{3}", file_name))
subject_id <- ifelse(length(id) == 1, id, NA_character_)
rm(id)
if (is.na(subject_id)) {
warning("Filename does not contain a valid 'sub-###' pattern: ", file_name)
}
#### Subset questionnaire vs. task -------------------------------------------
task_df <- df[df$trialType == "iat", , drop = FALSE]
questionnaire_df <- df[df$trialType == "Questionnaire", , drop = FALSE]
if (nrow(questionnaire_df) != 1) {
warning("Empty 'questionnaire_df' where data expected. In future steps, 'score_questionnaire' will not run correctly.")
}
#### Calculate Behavior & Questionnaire Scores -------------------------------
behavior <- summarize_behavior(task_df)
anxiety_score <- score_questionnaire(questionnaire_df$response)
#### Save participant summary ------------------------------------------------
## Ensure output directory is created
dir.create(
here::here("data", "cleaned", "participants"),
recursive = TRUE,
showWarnings = FALSE
)
## Combine into a single-row participant summary
df_clean <- data.frame(
subject_id = subject_id,
anxiety_score = anxiety_score,
congruent_mean = behavior["congruent_mean"],
incongruent_mean = behavior["incongruent_mean"],
congruent_accuracy = behavior["congruent_accuracy"],
incongruent_accuracy = behavior["incongruent_accuracy"],
d_score = behavior["d_score"],
row.names = NULL
)
## Save summary CSV to cleaned/participants
write.csv(
df_clean,
here::here("data", "cleaned", "participants", paste0(subject_id, "_cleaned.csv")),
row.names = FALSE
)
#### Return output -----------------------------------------------------------
stopifnot(nrow(df_clean) == 1)  # one row per participant
return(df_clean)
}
for (i in seq_along(files)) {
file_name <- files[i]
rows[[i]] <- import_and_process(file_name)
}
length(test_data$rt)
length(test_data_rt$rt)
test_data_rt <- valid_data_rt[grepl(" or ", valid_data_rt$expectedCategory), , drop = FALSE]
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
summarize_behavior <- function(data, rt_min = 300, rt_max = 900) {
## Check if rt column is numeric
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
# if (!is.numeric(data$rt)) data$rt <- as.numeric(data$rt)
#
## Change correct column to logical
## Create robust version of as.logical()
normalize_logical <- function(x) {
if (is.logical(x)) return(x)
if (is.numeric(x)) return(x == 1)
if (is.character(x)) return(toupper(x) == "TRUE")
as.logical(x)
}
if (!is.logical(data$correct)) {
data$correct <- normalize_logical(data$correct)
}
## Filter out trials where RT was outside of the threshold range
valid_data_rt <- data[data[ , 3] >= 300 & data[ , 3] <= 900 & data[ , 12] == TRUE, ]
valid_data_acc <- data[data[ , 3] >= 300 & data[ , 3] <= 900, ]
## Center each participant’s reaction times:
## subtract the participant’s mean RT so centered RTs average to zero
valid_data_rt$rt_centered <- NA_real_
for (i in 1:nrow(valid_data_rt)) {
valid_data_rt$rt_centered[i] <- valid_data_rt$rt[i] - mean(valid_data_rt$rt, na.rm = TRUE)
}
## Prepare test trials by excluding practice trials
## Keep only trials where expectedCategory is:
## "school or anxiety" OR "nature or serenity" (congruent)
## "school or serenity" OR "nature or anxiety" (incongruent)
test_data_rt <- valid_data_rt[grepl(" or ", valid_data_rt$expectedCategory), , drop = FALSE]
test_data_acc <- valid_data_acc[grepl(" or ", valid_data_acc$expectedCategory), , drop = FALSE]
## Group trials by the category displayed
desired_order <- c(
"nature or serenity or school or anxiety",
"nature or anxiety or school or serenity"
)
grp_rt <- factor(
test_data_rt$expectedCategoryDisplayed,
levels = desired_order
)
grp_acc <- factor(
test_data_acc$expectedCategoryAsDisplayed,
levels = desired_order
)
## Calculate mean rt
means <- tapply(test_data_rt$rt, grp_rt, FUN = mean)
## If you see “arguments must have same length” from tapply(), check whether the grouping variable (grp) has the same number of rows as test_data$rt. Inspect grp and test_data side by side:
##   length(test_data$rt)
##   length(grp)
## A mismatched or misspelled column name in the factor() call will usually cause this.
## Calculate mean accuracy
accuracy <- tapply(test_data_acc$correct, grp_acc, FUN = mean)
## Calculate D Score
d_score  <- calculate_iat_dscore(test_data_rt)
## Create one-row summary data frame
participant_summary <- data.frame(
congruent_mean       = means[1],
incongruent_mean     = means[2],
congruent_accuracy   = accuracy[1],
incongruent_accuracy = accuracy[2],
d_score              = d_score,
stringsAsFactors     = FALSE,
row.names            = NULL
)
## Ensure Accuracy Values are between 0 and 1
acc_cols <- c("congruent_accuracy", "incongruent_accuracy")
for (col in acc_cols) {
val <- participant_summary[[col]]
if (!is.na(val) && (val < 0 || val > 1)) {
warning(paste(col, "is outside [0, 1]. Check 'correct' coding."))
}
}
## Ensure Mean RTs within [rt_min, rt_max]
rt_cols <- c("congruent_mean", "incongruent_mean")
for (col in rt_cols) {
val <- participant_summary[[col]]
if (!is.na(val) && (val < rt_min || val > rt_max)) {
warning(paste(col, "is outside range [", rt_min, ", ", rt_max, "]."))
}
}
return(participant_summary)
}
valid_data_rt <- data[data[ , 3] >= 300 & data[ , 3] <= 900 & data[ , 12] == TRUE, ]
summarize_behavior <- function(data, rt_min = 300, rt_max = 900) {
## Check if rt column is numeric
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
normalize_logical <- function(x) {
if (is.logical(x)) return(x)
if (is.numeric(x)) return(x == 1)
if (is.character(x)) return(toupper(x) == "TRUE")
as.logical(x)
}
if (!is.logical(data$correct)) {
data$correct <- normalize_logical(data$correct)
}
valid_data_rt <- data[data[ , 3] >= 300 & data[ , 3] <= 900 & data[ , 12] == TRUE, ]
valid_data_acc <- data[data[ , 3] >= 300 & data[ , 3] <= 900, ]
valid_data_rt$rt_centered <- NA_real_
for (i in 1:nrow(valid_data_rt)) {
valid_data_rt$rt_centered[i] <- valid_data_rt$rt[i] - mean(valid_data_rt$rt, na.rm = TRUE)
}
test_data_rt <- valid_data_rt[grepl(" or ", valid_data_rt$expectedCategory), , drop = FALSE]
test_data_acc <- valid_data_acc[grepl(" or ", valid_data_acc$expectedCategory), , drop = FALSE]
test_data_acc
desired_order <- c(
"nature or serenity or school or anxiety",
"nature or anxiety or school or serenity"
)
grp_rt <- factor(
test_data_rt$expectedCategoryDisplayed,
levels = desired_order
)
grp_acc <- factor(
test_data_acc$expectedCategoryAsDisplayed,
levels = desired_order
)
means <- tapply(test_data_rt$rt, grp_rt, FUN = mean)
accuracy <- tapply(test_data_acc$correct, grp_acc, FUN = mean)
d_score  <- calculate_iat_dscore(test_data_rt)
participant_summary <- data.frame(
congruent_mean       = means[1],
incongruent_mean     = means[2],
congruent_accuracy   = accuracy[1],
incongruent_accuracy = accuracy[2],
d_score              = d_score,
stringsAsFactors     = FALSE,
row.names            = NULL
)
acc_cols <- c("congruent_accuracy", "incongruent_accuracy")
for (col in acc_cols) {
val <- participant_summary[[col]]
if (!is.na(val) && (val < 0 || val > 1)) {
warning(paste(col, "is outside [0, 1]. Check 'correct' coding."))
}
}
rt_cols <- c("congruent_mean", "incongruent_mean")
for (col in rt_cols) {
val <- participant_summary[[col]]
if (!is.na(val) && (val < rt_min || val > rt_max)) {
warning(paste(col, "is outside range [", rt_min, ", ", rt_max, "]."))
}
}
test_data_rt <- valid_data_rt[grepl(" or ", valid_data_rt$expectedCategory), , drop = FALSE]
names(test_data_rt)
names(valid_data_rt)
print(names(test_data_rt))
participant_wide <- build_participant_wide()
nrow(participant_wide)
head(participant_wide, 6)
tail(participant_wide, 6)
nrow(participant_wide)
nrow(participant_wide)
print(nrow(participant_wide))
participant_wide <- build_participant_wide()
cols <- c("congruent_mean", "incongruent_mean",
"congruent_accuracy", "incongruent_accuracy",
"d_score", "anxiety_score")
participant_wide[, cols] |>
is.na() |>
colSums() |>
(\(x) {
data.frame(
variable  = names(x),
n_missing = unname(x),
expected  = 0
)
})() |>
print()
length(test_data$rt)
## If you see “arguments must have same length” from tapply(), check whether the grouping variable (grp) has the same number of rows as test_data$rt. Inspect grp and test_data side by side:
length(test_data$rt)
participant_wide <- build_participant_wide()
nrow(participant_wide)
head(participant_wide, 6)
tail(participant_wide, 6)
participant_wide <- build_participant_wide()
nrow(participant_wide)
1 + 1
print("hello from console")
participant_wide <- build_participant_wide()
